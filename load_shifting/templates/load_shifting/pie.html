<!DOCTYPE html>
<title>Updating pie chart d3 v4</title>
<meta charset="utf-8">
<style>

  body {
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    margin: auto;
    position: relative;
    width: 960px;
  }

  text {
      font: 32px sans-serif;
      font-weight: bold;
      fill: black;
  }

  form {
    position: absolute;
    right: 10px;
    top: 10px;
  }

  input {
    margin: 0 7px;
  }

</style>
<form></form>
<p>Hourly data for CAISO from EIA. Orange = Solar, Red = Nat gas

  Maybe draw a clock in the middle of the donut chart, change background from light to
  dark to help distinguish am /pm ?

  Add a drop-down menu to pick a BA.

  Make the size of the circle represent total production / demand!!

  Host d3.v4.min.js ourself
</p>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

  var myDuration = 600;
  var firstTime = true;

  var width = 960,
  height = 500,
  radius = Math.min(width, height) / 2;

  /*var width = 960,
  height = 500,
  radius = Math.min(width, height) / 2;*/
  // var color = d3.scaleOrdinal(d3.schemeCategory20);

  
  var pie = d3.pie()
  .value(function(d) { return d.mwh; })
  .sort(null);

  var arc = d3.arc()
  .innerRadius(radius - 100)
  .outerRadius(radius - 20);

  var svg = d3.select("body").append("svg")
  .attr("width", width)
  .attr("height", height)
  .append("g")
  .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");


  /*svg.append("text")
    .text("Hour")
    .attr("x", 0)
    .attr("y", 0)
    .attr("text-anchor", "middle");*/
    /*.attr("stroke", "#ffff00")
    .attr("fill", "#ffff00");*/



  d3.json("/load_shifting/energy_mix.json", function(data) {

      function color(d) {
	  return {
	      "Solar": "orange",
	      "Wind": "#17becf",
	      "Hydro": "blue",
	      "Nuclear": "grey",
	      "Natural gas": "red",
	      "Coal": "black",
	      "Petroleum": "brown",
	      "Other": "green"
	  }[d];
      }

      /*var label = d3.select("form").selectAll("label")
	  .data(data["data_series"])
	  .enter().append("label");

      label.append("input")
	  .attr("type", "radio")
	  .attr("name", "used to be fruit")
	  .attr("value", function(d) { return d.key; })
	  .on("change", change_hour)
	  .filter(function(d, i) { return !i; })
	  .each(change_hour)
	  .property("checked", true);

      label.append("span")
	  .text(function(d) { return d.key; });
	  */

      function change_chart_to_hour(data_series_for_hour) {
	  console.log("Hour changed to " + JSON.stringify(data_series_for_hour));
	  var path = svg.selectAll("path");
	  var data0 = path.data(),
	      data1 = pie(data_series_for_hour.values);
	  
	  path = path.data(data1, key);
	  
	  path.transition()
	      .duration(myDuration)
	      .attrTween("d", arcTween)
	  

	  path.enter()
	      .append("path")
	      .each(function(d, i) {
		  var narc = findNeighborArc(i, data0, data1, key) ;
		  if(narc) {          
		      this._current = narc;
		      this._previous = narc;
		  } else {          
		      this._current = d;
		  }
	      }) 
	      .attr("fill", function(d,i) { 
		  return color(d.data.fuel)
	      })
	      .transition()
	      .duration(myDuration)
	      .attrTween("d", arcTween)
	  
	  
	  path.exit()
	      .transition()
	      .duration(myDuration)
	      .attrTween("d", function(d, index) {
		  
		  var currentIndex = this._previous.data.fuel;
		  var i = d3.interpolateObject(d,this._previous);
		  return function(t) {
		      return arc(i(t))
		  }
		  
	      })
	      .remove()
	  firstTime = false;

      }

      function change_label_to_hour( new_hour ) {
	  console.log("Change label to " + new_hour);
	  var text_label = svg.selectAll("text");
	  text_label.data([new_hour]);

	  text_label.enter()
	      .append("text")
	      .text( function(d) { return d })
	      .attr("x", width/2)
	      .attr("y", height/2)
	      .attr("stroke", "#000000");

	  /*text_label.update()
	      .text( function(d) { return d });*/

      }


      var current_hour = 0;
      const t = d3.interval((elapsed) => {
	  current_hour = (current_hour + 1) % 24;

	  var hour_series = data["data_series"].find((element) => element["key"] == "Hour = " + current_hour);
	  //console.log(current_hour);
	  change_chart_to_hour(hour_series);
	  change_label_to_hour(current_hour);
      }, 1000, 0);
      
  });

  function key(d) {
    return d.data.fuel;
  }

  function type(d) {
    d.mwh = +d.mwh;
    return d;
  }

  function findNeighborArc(i, data0, data1, key) {
    var d;
    if(d = findPreceding(i, data0, data1, key)) {

      var obj = cloneObj(d)
      obj.startAngle = d.endAngle;
      return obj;

    } else if(d = findFollowing(i, data0, data1, key)) {

      var obj = cloneObj(d)
      obj.endAngle = d.startAngle;
      return obj;

    }

    return null


  }

// Find the element in data0 that joins the highest preceding element in data1.
function findPreceding(i, data0, data1, key) {
  var m = data0.length;
  while (--i >= 0) {
    var k = key(data1[i]);
    for (var j = 0; j < m; ++j) {
      if (key(data0[j]) === k) return data0[j];
    }
  }
}

// Find the element in data0 that joins the lowest following element in data1.
function findFollowing(i, data0, data1, key) {
  var n = data1.length, m = data0.length;
  while (++i < n) {
    var k = key(data1[i]);
    for (var j = 0; j < m; ++j) {
      if (key(data0[j]) === k) return data0[j];
    }
  }
}

function arcTween(d) {

  var i = d3.interpolate(this._current, d);

  this._current = i(0);

  return function(t) {
    return arc(i(t))
  }

}


function cloneObj(obj) {
  var o = {};
  for(var i in obj) {
    o[i] = obj[i];
  }
  return o;
}
</script>
